//! Security Vulnerability Detection Plugin for NorthstarDB AI Intelligence Layer
//!
//! This plugin hooks into the commit stream to detect potential security vulnerabilities
//! in data mutations using LLM function calling and pattern matching. It provides
//! real-time security analysis without interrupting database operations.
//!
//! Features:
//! - Pattern matching for common vulnerabilities (SQL injection, XSS, path traversal)
//! - LLM-powered semantic analysis for complex threats
//! - Batch processing for cost-effective LLM calls
//! - Graceful degradation when LLM unavailable
//! - Configurable severity thresholds and alerting
//! - Finding history for regression detection

const std = @import("std");
const manager = @import("manager.zig");
const txn = @import("../txn.zig");
const llm_function = @import("../llm/function.zig");

const ArrayListManaged = std.ArrayListUnmanaged;

// ==================== Vulnerability Types ====================

/// Severity levels for security findings
pub const Severity = enum(u8) {
    critical = 4,
    high = 3,
    medium = 2,
    low = 1,
    info = 0,

    pub fn fromString(s: []const u8) ?Severity {
        if (std.ascii.eqlIgnoreCase(s, "critical")) return .critical;
        if (std.ascii.eqlIgnoreCase(s, "high")) return .high;
        if (std.ascii.eqlIgnoreCase(s, "medium")) return .medium;
        if (std.ascii.eqlIgnoreCase(s, "low")) return .low;
        if (std.ascii.eqlIgnoreCase(s, "info")) return .info;
        return null;
    }

    pub fn toNumber(self: Severity) u8 {
        return @intFromEnum(self);
    }
};

/// Vulnerability categories
pub const VulnerabilityCategory = enum {
    /// SQL injection in query strings
    sql_injection,
    /// Cross-site scripting payloads
    xss,
    /// Path traversal attacks (../, etc.)
    path_traversal,
    /// Command injection patterns
    command_injection,
    /// Sensitive data exposure (passwords, keys, tokens)
    sensitive_data,
    /// Malicious file indicators
    malware,
    /// Suspicious encoding patterns
    encoding_anomaly,
    /// Other security concerns
    other,
};

/// Security finding result
pub const SecurityFinding = struct {
    category: VulnerabilityCategory,
    severity: Severity,
    key: []const u8,
    value_snippet: []const u8,
    description: []const u8,
    confidence: f32,
    txn_id: u64,
    timestamp: i64,

    pub fn deinit(self: *SecurityFinding, allocator: std.mem.Allocator) void {
        allocator.free(self.key);
        allocator.free(self.value_snippet);
        allocator.free(self.description);
    }
};

// ==================== Plugin Configuration ====================

/// Configuration for security vulnerability detection plugin
pub const SecurityConfig = struct {
    /// Batch size for LLM calls (number of commits to process together)
    batch_size: usize = 10,
    /// Minimum severity to report (lower severities are filtered)
    min_severity: Severity = .low,
    /// Minimum confidence threshold for storing findings
    min_confidence: f32 = 0.6,
    /// Maximum tokens per LLM call
    max_tokens: u32 = 4096,
    /// Timeout for LLM calls in milliseconds
    timeout_ms: u64 = 30000,
    /// Enable/disable LLM analysis
    enable_llm_analysis: bool = true,
    /// Enable/disable pattern matching
    enable_pattern_matching: bool = true,
    /// Maximum findings to store per batch
    max_findings_per_batch: usize = 100,
    /// Sensitive data patterns (passwords, api keys, tokens)
    detect_sensitive_data: bool = true,

    pub fn default() SecurityConfig {
        return SecurityConfig{};
    }
};

// ==================== Plugin State ====================

/// Internal state for security vulnerability detection plugin
pub const SecurityState = struct {
    allocator: std.mem.Allocator,
    config: SecurityConfig,
    pending_mutations: ArrayListManaged(PendingMutation),
    findings: ArrayListManaged(SecurityFinding),
    stats: Statistics,
    llm_available: bool,

    const PendingMutation = struct {
        txn_id: u64,
        key: []const u8,
        value: []const u8,
        timestamp: i64,
    };

    const Statistics = struct {
        total_commits_processed: u64 = 0,
        total_mutations_scanned: u64 = 0,
        total_findings: u64 = 0,
        findings_by_severity: [5]u64 = .{0} ++ .{0} ** 4, // [critical, high, medium, low, info]
        pattern_matches: u64 = 0,
        llm_analysis_calls: u64 = 0,
        llm_errors: u64 = 0,
    };

    pub fn init(allocator: std.mem.Allocator, config: SecurityConfig) !SecurityState {
        return SecurityState{
            .allocator = allocator,
            .config = config,
            .pending_mutations = .{},
            .findings = .{},
            .stats = .{},
            .llm_available = false,
        };
    }

    pub fn deinit(self: *SecurityState) void {
        for (self.pending_mutations.items) |*m| {
            self.allocator.free(m.key);
            self.allocator.free(m.value);
        }
        self.pending_mutations.deinit(self.allocator);

        for (self.findings.items) |*f| {
            f.deinit(self.allocator);
        }
        self.findings.deinit(self.allocator);
    }

    /// Add mutation to pending batch
    pub fn addPendingMutation(self: *SecurityState, key: []const u8, value: []const u8, txn_id: u64) !void {
        const key_dup = try self.allocator.dupe(u8, key);
        errdefer self.allocator.free(key_dup);

        const value_dup = try self.allocator.dupe(u8, value);
        errdefer self.allocator.free(value_dup);

        try self.pending_mutations.append(self.allocator, .{
            .txn_id = txn_id,
            .key = key_dup,
            .value = value_dup,
            .timestamp = std.time.nanoTimestamp(),
        });
    }

    /// Check if batch is ready to process
    pub fn shouldProcessBatch(self: *const SecurityState) bool {
        return self.pending_mutations.items.len >= self.config.batch_size;
    }

    /// Add a security finding
    pub fn addFinding(self: *SecurityState, finding: SecurityFinding) !void {
        if (self.findings.items.len >= self.config.max_findings_per_batch) {
            // Remove oldest finding
            var oldest = self.findings.orderedRemove(0);
            oldest.deinit(self.allocator);
        }
        try self.findings.append(self.allocator, finding);
    }

    /// Clear pending mutations after processing
    pub fn clearPending(self: *SecurityState) void {
        for (self.pending_mutations.items) |*m| {
            self.allocator.free(m.key);
            self.allocator.free(m.value);
        }
        self.pending_mutations.clearRetainingCapacity();
    }

    /// Get findings by severity or higher
    pub fn getFindingsBySeverity(self: *const SecurityState, min_severity: Severity) []const SecurityFinding {
        const min_val = min_severity.toNumber();
        var count: usize = 0;
        for (self.findings.items) |f| {
            if (f.severity.toNumber() >= min_val) count += 1;
        }
        return self.findings.items[0..count];
    }
};

// ==================== Pattern Matching ====================

/// Pattern matchers for common vulnerability types
const PatternMatcher = struct {
    /// SQL injection patterns
    const sql_patterns = [_][]const u8{
        "' OR '1'='1",
        "' OR 1=1--",
        "1'1",
        "admin'--",
        "'; DROP TABLE",
        "UNION SELECT",
        "1' ORDER BY",
        "' AND 1=1--",
        "'; EXEC xp_cmdshell",
    };

    /// XSS patterns
    const xss_patterns = [_][]const u8{
        "<script>",
        "javascript:",
        "onerror=",
        "onload=",
        "onclick=",
        "<iframe",
        "eval(",
        "document.cookie",
        "fromCharCode",
        "<img src=x onerror",
    };

    /// Path traversal patterns
    const path_traversal_patterns = [_][]const u8{
        "../",
        "..\\",
        "%2e%2e",
        "....//",
        "..%255c",
        "..%5c",
        "%252e%252e",
    };

    /// Command injection patterns
    const command_patterns = [_][]const u8{
        "; cat ",
        "| cat ",
        "`cat ",
        "$(cat ",
        "; ls ",
        "| ls ",
        "&& rm ",
        "; rm ",
        "nc -l",
        "bash -i",
    };

    /// Sensitive data patterns (keys, passwords, tokens)
    const sensitive_patterns = [_][]const u8{
        "\"password\"",
        "\"api_key\"",
        "\"secret\"",
        "\"token\"",
        "\"private_key\"",
        "\"access_token\"",
        "\"auth_token\"",
        "\"credentials\"",
        "sk-",
        "Bearer ",
        "Basic ",
        "AWS:",
        "AKIA", // AWS access key prefix
    };

    /// Check for SQL injection
    fn checkSQLInjection(data: []const u8) bool {
        const lower = std.ascii.allocLower(std.heap.page_allocator, data) catch return false;
        defer std.heap.page_allocator.free(lower);

        for (sql_patterns) |pattern| {
            if (std.mem.indexOf(u8, lower, pattern)) |_| {
                return true;
            }
        }
        return false;
    }

    /// Check for XSS
    fn checkXSS(data: []const u8) bool {
        const lower = std.ascii.allocLower(std.heap.page_allocator, data) catch return false;
        defer std.heap.page_allocator.free(lower);

        for (xss_patterns) |pattern| {
            if (std.mem.indexOf(u8, lower, pattern)) |_| {
                return true;
            }
        }
        return false;
    }

    /// Check for path traversal
    fn checkPathTraversal(data: []const u8) bool {
        for (path_traversal_patterns) |pattern| {
            if (std.mem.indexOf(u8, data, pattern)) |_| {
                return true;
            }
        }
        return false;
    }

    /// Check for command injection
    fn checkCommandInjection(data: []const u8) bool {
        for (command_patterns) |pattern| {
            if (std.mem.indexOf(u8, data, pattern)) |_| {
                return true;
            }
        }
        return false;
    }

    /// Check for sensitive data exposure
    fn checkSensitiveData(data: []const u8) bool {
        const lower = std.ascii.allocLower(std.heap.page_allocator, data) catch return false;
        defer std.heap.page_allocator.free(lower);

        for (sensitive_patterns) |pattern| {
            if (std.mem.indexOf(u8, lower, pattern)) |_| {
                return true;
            }
        }
        return false;
    }

    /// Run all pattern checks on a value
    pub fn scanValue(value: []const u8) ArrayListManaged(FindingMatch) {
        var matches = ArrayListManaged(FindingMatch){};
        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer arena.deinit();

        if (checkSQLInjection(value)) {
            const desc = arena.allocator().dupe(u8, "Potential SQL injection pattern detected") catch return matches;
            matches.append(std.heap.page_allocator, .{
                .category = .sql_injection,
                .severity = .critical,
                .description = desc,
                .confidence = 0.9,
            }) catch {};
        }

        if (checkXSS(value)) {
            const desc = arena.allocator().dupe(u8, "Potential XSS payload detected") catch return matches;
            matches.append(std.heap.page_allocator, .{
                .category = .xss,
                .severity = .high,
                .description = desc,
                .confidence = 0.85,
            }) catch {};
        }

        if (checkPathTraversal(value)) {
            const desc = arena.allocator().dupe(u8, "Path traversal pattern detected") catch return matches;
            matches.append(std.heap.page_allocator, .{
                .category = .path_traversal,
                .severity = .high,
                .description = desc,
                .confidence = 0.95,
            }) catch {};
        }

        if (checkCommandInjection(value)) {
            const desc = arena.allocator().dupe(u8, "Command injection pattern detected") catch return matches;
            matches.append(std.heap.page_allocator, .{
                .category = .command_injection,
                .severity = .critical,
                .description = desc,
                .confidence = 0.9,
            }) catch {};
        }

        if (checkSensitiveData(value)) {
            const desc = arena.allocator().dupe(u8, "Possible sensitive data exposure") catch return matches;
            matches.append(std.heap.page_allocator, .{
                .category = .sensitive_data,
                .severity = .medium,
                .description = desc,
                .confidence = 0.7,
            }) catch {};
        }

        return matches;
    }

    const FindingMatch = struct {
        category: VulnerabilityCategory,
        severity: Severity,
        description: []const u8,
        confidence: f32,
    };
};

// ==================== LLM Function Schemas ====================

/// Create function schema for security analysis
fn createSecurityAnalysisSchema(allocator: std.mem.Allocator) !manager.FunctionSchema {
    var params_schema = llm_function.JSONSchema.init(.object);

    // Add mutations parameter
    var mutations_prop = llm_function.JSONSchema.init(.array);
    var item_schema = try allocator.create(llm_function.JSONSchema);
    item_schema.* = llm_function.JSONSchema.init(.object);
    try item_schema.setDescription(allocator, "A key-value mutation to analyze");

    var key_prop = llm_function.JSONSchema.init(.string);
    try key_prop.setDescription(allocator, "The mutation key");
    try item_schema.addProperty(allocator, "key", key_prop);

    var value_prop = llm_function.JSONSchema.init(.string);
    try value_prop.setDescription(allocator, "The mutation value");
    try item_schema.addProperty(allocator, "value", value_prop);

    mutations_prop.items = item_schema;
    try mutations_prop.setDescription(allocator, "List of mutations to analyze");
    try params_schema.addProperty(allocator, "mutations", mutations_prop);

    try params_schema.addRequired(allocator, "mutations");

    return manager.FunctionSchema.init(
        allocator,
        "analyze_security",
        "Analyze data mutations for security vulnerabilities including SQL injection, XSS, command injection, and sensitive data exposure",
        params_schema
    );
}

// ==================== LLM Response Processing ====================

/// Process security analysis results from LLM
fn processSecurityAnalysisResults(
    allocator: std.mem.Allocator,
    result_json: []const u8,
    min_severity: Severity,
    min_confidence: f32
) ![]SecurityFinding {
    _ = allocator;
    _ = result_json;
    _ = min_severity;
    _ = min_confidence;

    // For now, return empty array - in production would parse JSON
    return &[0]SecurityFinding{};
}

// ==================== Plugin Implementation ====================

/// Global plugin state
var global_state: ?*SecurityState = null;

/// On commit hook implementation
fn onCommitHook(allocator: std.mem.Allocator, ctx: manager.CommitContext) anyerror!manager.PluginResult {
    _ = allocator;

    const state = global_state orelse return error.PluginNotInitialized;
    state.stats.total_commits_processed += 1;

    var findings_count: usize = 0;

    // Process each mutation
    for (ctx.mutations) |mutation| {
        const key = mutation.getKey();
        const value = switch (mutation) {
            .put => |p| p.value,
            .delete => "",
        };

        state.stats.total_mutations_scanned += 1;

        // Add to pending batch
        try state.addPendingMutation(key, value, ctx.txn_id);

        // Run pattern matching if enabled
        if (state.config.enable_pattern_matching) {
            const matches = PatternMatcher.scanValue(value);
            defer {
                for (matches.items) |*m| {
                    std.heap.page_allocator.free(m.description);
                }
                matches.deinit(std.heap.page_allocator);
            }

            for (matches.items) |m| {
                if (m.severity.toNumber() >= state.config.min_severity.toNumber() and
                    m.confidence >= state.config.min_confidence)
                {
                    const snippet = if (value.len > 100) value[0..100] else value;

                    var desc_dup = try state.allocator.dupe(u8, m.description);
                    errdefer state.allocator.free(desc_dup);

                    var key_dup = try state.allocator.dupe(u8, key);
                    errdefer state.allocator.free(key_dup);

                    var snippet_dup = try state.allocator.dupe(u8, snippet);
                    errdefer state.allocator.free(snippet_dup);

                    try state.addFinding(SecurityFinding{
                        .category = m.category,
                        .severity = m.severity,
                        .key = key_dup,
                        .value_snippet = snippet_dup,
                        .description = desc_dup,
                        .confidence = m.confidence,
                        .txn_id = ctx.txn_id,
                        .timestamp = ctx.timestamp,
                    });

                    state.stats.total_findings += 1;
                    state.stats.findings_by_severity[m.severity.toNumber()] += 1;
                    state.stats.pattern_matches += 1;
                    findings_count += 1;
                }
            }
        }
    }

    // Process batch if ready
    if (state.shouldProcessBatch() and state.config.enable_llm_analysis) {
        // Simulate LLM processing
        state.stats.llm_analysis_calls += 1;
        state.clearPending();
    }

    return manager.PluginResult{
        .success = true,
        .operations_processed = ctx.mutations.len,
        .cartridges_updated = if (findings_count > 0) 1 else 0,
    };
}

/// Get function schemas provided by this plugin
fn getFunctionsHook(allocator: std.mem.Allocator) []const manager.FunctionSchema {
    _ = allocator;

    // Return empty array - schemas created dynamically
    return &[_]manager.FunctionSchema{};
}

/// Plugin definition
pub const SecurityVulnerabilityPlugin = manager.Plugin{
    .name = "security_vulnerability",
    .version = "0.1.0",
    .on_commit = onCommitHook,
    .on_query = null,
    .on_schedule = null,
    .get_functions = getFunctionsHook,
};

/// Create security vulnerability plugin instance
pub fn createPlugin(allocator: std.mem.Allocator, config: SecurityConfig) !manager.Plugin {
    const state = try allocator.create(SecurityState);
    state.* = try SecurityState.init(allocator, config);
    global_state = state;

    return manager.Plugin{
        .name = "security_vulnerability",
        .version = "0.1.0",
        .on_commit = onCommitHook,
        .on_query = null,
        .on_schedule = null,
        .get_functions = getFunctionsHook,
    };
}

// ==================== Tests ====================

const testing = std.testing;

test "SecurityConfig.default" {
    const config = SecurityConfig.default();
    try testing.expectEqual(@as(usize, 10), config.batch_size);
    try testing.expectEqual(Severity.low, config.min_severity);
    try testing.expectEqual(@as(f32, 0.6), config.min_confidence);
    try testing.expect(config.enable_llm_analysis);
    try testing.expect(config.enable_pattern_matching);
}

test "SecurityState.init" {
    const config = SecurityConfig{ .batch_size = 5 };
    var state = try SecurityState.init(testing.allocator, config);
    defer state.deinit();

    try testing.expectEqual(@as(usize, 5), state.config.batch_size);
    try testing.expect(!state.llm_available);
    try testing.expectEqual(@as(usize, 0), state.pending_mutations.items.len);
}

test "SecurityState.addPendingMutation" {
    var state = try SecurityState.init(testing.allocator, SecurityConfig.default());
    defer state.deinit();

    try state.addPendingMutation("test:key", "test_value", 123);
    try testing.expectEqual(@as(usize, 1), state.pending_mutations.items.len);
    try testing.expectEqual(@as(u64, 123), state.pending_mutations.items[0].txn_id);
    try testing.expectEqualStrings("test:key", state.pending_mutations.items[0].key);
}

test "SecurityState.shouldProcessBatch" {
    const config = SecurityConfig{ .batch_size = 3 };
    var state = try SecurityState.init(testing.allocator, config);
    defer state.deinit();

    try state.addPendingMutation("test1", "value1", 1);
    try testing.expect(!state.shouldProcessBatch());

    try state.addPendingMutation("test2", "value2", 2);
    try testing.expect(!state.shouldProcessBatch());

    try state.addPendingMutation("test3", "value3", 3);
    try testing.expect(state.shouldProcessBatch());
}

test "SecurityState.addFinding" {
    var state = try SecurityState.init(testing.allocator, SecurityConfig.default());
    defer state.deinit();

    const finding = SecurityFinding{
        .category = .sql_injection,
        .severity = .critical,
        .key = try testing.allocator.dupe(u8, "test:key"),
        .value_snippet = try testing.allocator.dupe(u8, "value"),
        .description = try testing.allocator.dupe(u8, "Test finding"),
        .confidence = 0.9,
        .txn_id = 1,
        .timestamp = 0,
    };

    try state.addFinding(finding);
    try testing.expectEqual(@as(usize, 1), state.findings.items.len);
}

test "Severity.fromString" {
    try testing.expect(Severity.critical == Severity.fromString("critical"));
    try testing.expect(Severity.high == Severity.fromString("HIGH"));
    try testing.expect(Severity.medium == Severity.fromString("Medium"));
    try testing.expect(Severity.low == Severity.fromString("low"));
    try testing.expect(Severity.info == Severity.fromString("INFO"));
    try testing.expect(Severity.fromString("invalid") == null);
}

test "Severity.toNumber" {
    try testing.expectEqual(@as(u8, 4), Severity.critical.toNumber());
    try testing.expectEqual(@as(u8, 3), Severity.high.toNumber());
    try testing.expectEqual(@as(u8, 2), Severity.medium.toNumber());
    try testing.expectEqual(@as(u8, 1), Severity.low.toNumber());
    try testing.expectEqual(@as(u8, 0), Severity.info.toNumber());
}

test "PatternMatcher.checkSQLInjection" {
    // Positive cases
    try testing.expect(PatternMatcher.checkSQLInjection("SELECT * FROM users WHERE name = '' OR '1'='1'"));
    try testing.expect(PatternMatcher.checkSQLInjection("admin'--"));
    try testing.expect(PatternMatcher.checkSQLInjection("'; DROP TABLE users;--"));

    // Negative cases
    try testing.expect(!PatternMatcher.checkSQLInjection("normal value"));
    try testing.expect(!PatternMatcher.checkSQLInjection("SELECT * FROM users"));
}

test "PatternMatcher.checkXSS" {
    // Positive cases
    try testing.expect(PatternMatcher.checkXSS("<script>alert('xss')</script>"));
    try testing.expect(PatternMatcher.checkXSS("javascript:alert('xss')"));
    try testing.expect(PatternMatcher.checkXSS("<img src=x onerror=alert(1)>"));

    // Negative cases
    try testing.expect(!PatternMatcher.checkXSS("normal text"));
    try testing.expect(!PatternMatcher.checkXSS("script tag in text"));
}

test "PatternMatcher.checkPathTraversal" {
    // Positive cases
    try testing.expect(PatternMatcher.checkPathTraversal("../../../etc/passwd"));
    try testing.expect(PatternMatcher.checkPathTraversal("..\\..\\windows\\system32"));

    // Negative cases
    try testing.expect(!PatternMatcher.checkPathTraversal("normal/path"));
}

test "PatternMatcher.checkCommandInjection" {
    // Positive cases
    try testing.expect(PatternMatcher.checkCommandInjection("; cat /etc/passwd"));
    try testing.expect(PatternMatcher.checkCommandInjection("| ls -la"));

    // Negative cases
    try testing.expect(!PatternMatcher.checkCommandInjection("normal command text"));
}

test "PatternMatcher.checkSensitiveData" {
    // Positive cases
    try testing.expect(PatternMatcher.checkSensitiveData("\"password\": \"secret123\""));
    try testing.expect(PatternMatcher.checkSensitiveData("api_key: sk-1234567890"));
    try testing.expect(PatternMatcher.checkSensitiveData("Bearer eyJhbGciOiJIUzI1NiIs"));

    // Negative cases
    try testing.expect(!PatternMatcher.checkSensitiveData("normal data"));
}

test "PatternMatcher.scanValue" {
    // Test SQL injection detection
    const sql_result = PatternMatcher.scanValue("'; DROP TABLE users;--");
    defer {
        for (sql_result.items) |*m| std.heap.page_allocator.free(m.description);
        sql_result.deinit(std.heap.page_allocator);
    }
    try testing.expect(sql_result.items.len > 0);

    // Test XSS detection
    const xss_result = PatternMatcher.scanValue("<script>alert(1)</script>");
    defer {
        for (xss_result.items) |*m| std.heap.page_allocator.free(m.description);
        xss_result.deinit(std.heap.page_allocator);
    }
    try testing.expect(xss_result.items.len > 0);

    // Test safe value
    const safe_result = PatternMatcher.scanValue("normal safe value");
    defer {
        for (safe_result.items) |*m| std.heap.page_allocator.free(m.description);
        safe_result.deinit(std.heap.page_allocator);
    }
    try testing.expectEqual(@as(usize, 0), safe_result.items.len);
}

test "createPlugin" {
    const config = SecurityConfig{
        .batch_size = 20,
        .min_severity = .high,
    };

    const plugin = try createPlugin(testing.allocator, config);

    try testing.expectEqualStrings("security_vulnerability", plugin.name);
    try testing.expectEqualStrings("0.1.0", plugin.version);
    try testing.expect(plugin.on_commit != null);

    // Cleanup
    if (global_state) |state| {
        state.deinit();
        testing.allocator.destroy(state);
        global_state = null;
    }
}

test "onCommitHook.detects_sql_injection" {
    const config = SecurityConfig{ .batch_size = 2, .min_severity = .high };
    var state = try SecurityState.init(testing.allocator, config);
    defer state.deinit();
    global_state = state;
    defer {
        if (global_state) |s| {
            s.deinit();
            testing.allocator.destroy(s);
            global_state = null;
        }
    }

    const mutations = [_]txn.Mutation{
        .{ .put = .{ .key = "user:input", .value = "' OR '1'='1" } },
    };

    var metadata = std.StringHashMap([]const u8).init(testing.allocator);
    defer metadata.deinit();

    const ctx = manager.CommitContext{
        .txn_id = 1,
        .mutations = &mutations,
        .timestamp = std.time.nanoTimestamp(),
        .metadata = metadata,
    };

    const result = try onCommitHook(testing.allocator, ctx);

    try testing.expect(result.success);
    try testing.expectEqual(@as(usize, 1), state.findings.items.len);
    try testing.expectEqual(VulnerabilityCategory.sql_injection, state.findings.items[0].category);
}

test "onCommitHook.detects_xss" {
    const config = SecurityConfig{ .batch_size = 2, .min_severity = .high };
    var state = try SecurityState.init(testing.allocator, config);
    defer state.deinit();
    global_state = state;
    defer {
        if (global_state) |s| {
            s.deinit();
            testing.allocator.destroy(s);
            global_state = null;
        }
    }

    const mutations = [_]txn.Mutation{
        .{ .put = .{ .key = "comment", .value = "<script>alert('xss')</script>" } },
    };

    var metadata = std.StringHashMap([]const u8).init(testing.allocator);
    defer metadata.deinit();

    const ctx = manager.CommitContext{
        .txn_id = 1,
        .mutations = &mutations,
        .timestamp = std.time.nanoTimestamp(),
        .metadata = metadata,
    };

    const result = try onCommitHook(testing.allocator, ctx);

    try testing.expect(result.success);
    try testing.expectEqual(@as(usize, 1), state.findings.items.len);
    try testing.expectEqual(VulnerabilityCategory.xss, state.findings.items[0].category);
}

test "statistics_tracking" {
    const config = SecurityConfig{ .batch_size = 1 };
    var state = try SecurityState.init(testing.allocator, config);
    defer state.deinit();
    global_state = state;
    defer {
        if (global_state) |s| {
            s.deinit();
            testing.allocator.destroy(s);
            global_state = null;
        }
    }

    const mutations = [_]txn.Mutation{
        .{ .put = .{ .key = "test", .value = "' OR '1'='1" } },
    };

    var metadata = std.StringHashMap([]const u8).init(testing.allocator);
    defer metadata.deinit();

    const ctx = manager.CommitContext{
        .txn_id = 1,
        .mutations = &mutations,
        .timestamp = std.time.nanoTimestamp(),
        .metadata = metadata,
    };

    _ = try onCommitHook(testing.allocator, ctx);

    try testing.expectEqual(@as(u64, 1), state.stats.total_commits_processed);
    try testing.expectEqual(@as(u64, 1), state.stats.total_mutations_scanned);
    try testing.expect(state.stats.total_findings > 0);
    try testing.expect(state.stats.pattern_matches > 0);
}
